[
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "bisect",
        "importPath": "bisect",
        "description": "bisect",
        "isExtraImport": true,
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "perf_counter",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "grade_using_bisect_by_dict",
        "importPath": "code",
        "description": "code",
        "isExtraImport": true,
        "detail": "code",
        "documentation": {}
    },
    {
        "label": "took_how_long",
        "importPath": "code",
        "description": "code",
        "isExtraImport": true,
        "detail": "code",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "Gender",
        "kind": 6,
        "importPath": "OOP.abstract_classes",
        "description": "OOP.abstract_classes",
        "peekOfCode": "class Gender(Enum):\n    MALE = 'male'\n    FEMALE = 'female'\nclass Human(metaclass=ABCMeta):\n    \"\"\" Base class for all humans \"\"\"\n    def __init__(self, name: str, age: int, height: float, weight: float) -> None:\n        self.name = name\n        self.age = age\n        self.height = height\n        self.weight = weight",
        "detail": "OOP.abstract_classes",
        "documentation": {}
    },
    {
        "label": "Human",
        "kind": 6,
        "importPath": "OOP.abstract_classes",
        "description": "OOP.abstract_classes",
        "peekOfCode": "class Human(metaclass=ABCMeta):\n    \"\"\" Base class for all humans \"\"\"\n    def __init__(self, name: str, age: int, height: float, weight: float) -> None:\n        self.name = name\n        self.age = age\n        self.height = height\n        self.weight = weight\n    @abstractmethod\n    def walk(self) -> None:\n        ...",
        "detail": "OOP.abstract_classes",
        "documentation": {}
    },
    {
        "label": "Male",
        "kind": 6,
        "importPath": "OOP.abstract_classes",
        "description": "OOP.abstract_classes",
        "peekOfCode": "class Male(Human):\n    \"\"\" A male specie of the human race \"\"\"\n    def __init__(self, name: str, age: int, height: float, weight: float) -> None:\n        super().__init__(name, age, height, weight)\n        self.sex = Gender.MALE\nclass Female(Human):\n    \"\"\" A female specie of the human race \"\"\"\n    def __init__(self, name: str, age: int, height: float, weight: float) -> None:\n        super().__init__(name, age, height, weight)\n        self.sex = Gender.FEMALE",
        "detail": "OOP.abstract_classes",
        "documentation": {}
    },
    {
        "label": "Female",
        "kind": 6,
        "importPath": "OOP.abstract_classes",
        "description": "OOP.abstract_classes",
        "peekOfCode": "class Female(Human):\n    \"\"\" A female specie of the human race \"\"\"\n    def __init__(self, name: str, age: int, height: float, weight: float) -> None:\n        super().__init__(name, age, height, weight)\n        self.sex = Gender.FEMALE",
        "detail": "OOP.abstract_classes",
        "documentation": {}
    },
    {
        "label": "took_how_long",
        "kind": 2,
        "importPath": "code.bisect.code",
        "description": "code.bisect.code",
        "peekOfCode": "def took_how_long(function, *args, **kwargs) -> None:\n    \"\"\" helper function to get time of execution \"\"\"\n    start = perf_counter()\n    function(*args, **kwargs)\n    print(perf_counter() - start)\n# It is possible to achieve this using the below algorithm but\n# this could be a poor solution in terms of code reusability\n# depending on the scenario it could do the trick\ndef calculate_grade(grade: int) -> str:\n    if grade > 74:",
        "detail": "code.bisect.code",
        "documentation": {}
    },
    {
        "label": "calculate_grade",
        "kind": 2,
        "importPath": "code.bisect.code",
        "description": "code.bisect.code",
        "peekOfCode": "def calculate_grade(grade: int) -> str:\n    if grade > 74:\n        return 'A1'\n    if grade > 69:\n        return 'B2'\n    if grade > 64:\n        return 'B3'\n    if grade > 59:\n        return 'C4'\n    if grade > 54:",
        "detail": "code.bisect.code",
        "documentation": {}
    },
    {
        "label": "grade_using_bisect_by_list",
        "kind": 2,
        "importPath": "code.bisect.code",
        "description": "code.bisect.code",
        "peekOfCode": "def grade_using_bisect_by_list(score: int, *, breakpoints: List[int], grades: List[str]) -> str:\n    grade = bisect(breakpoints, score) - 1\n    return grades[grade]\n# Here is a dynamic approach, grade mapping can be updated dynamically\n# We create a mapping of scores to grades\ngrade_map = {\n    'F9': 0,\n    'E8': 40,\n    'C4': 60,\n    'C6': 50,",
        "detail": "code.bisect.code",
        "documentation": {}
    },
    {
        "label": "grade_using_bisect_by_dict",
        "kind": 2,
        "importPath": "code.bisect.code",
        "description": "code.bisect.code",
        "peekOfCode": "def grade_using_bisect_by_dict(score: int, *,\n                               grade_map: Dict[str, Any],\n                               requires_sorting=False, key=None) -> str:\n    if requires_sorting:\n        assert key is not None, (\n            'key is required to perform sorting'\n        )\n        sorted(grade_map, key=key)\n    grades = list(grade_map.keys())\n    breakpoints = list(grade_map.values())",
        "detail": "code.bisect.code",
        "documentation": {}
    },
    {
        "label": "breakpoints",
        "kind": 5,
        "importPath": "code.bisect.code",
        "description": "code.bisect.code",
        "peekOfCode": "breakpoints = [0, 40, 45, 50, 55, 60, 65, 70, 75]\ngrades = ['F9', 'E8', 'D7', 'C6', 'C5', 'C4', 'B3', 'B2', 'A1']\ndef grade_using_bisect_by_list(score: int, *, breakpoints: List[int], grades: List[str]) -> str:\n    grade = bisect(breakpoints, score) - 1\n    return grades[grade]\n# Here is a dynamic approach, grade mapping can be updated dynamically\n# We create a mapping of scores to grades\ngrade_map = {\n    'F9': 0,\n    'E8': 40,",
        "detail": "code.bisect.code",
        "documentation": {}
    },
    {
        "label": "grades",
        "kind": 5,
        "importPath": "code.bisect.code",
        "description": "code.bisect.code",
        "peekOfCode": "grades = ['F9', 'E8', 'D7', 'C6', 'C5', 'C4', 'B3', 'B2', 'A1']\ndef grade_using_bisect_by_list(score: int, *, breakpoints: List[int], grades: List[str]) -> str:\n    grade = bisect(breakpoints, score) - 1\n    return grades[grade]\n# Here is a dynamic approach, grade mapping can be updated dynamically\n# We create a mapping of scores to grades\ngrade_map = {\n    'F9': 0,\n    'E8': 40,\n    'C4': 60,",
        "detail": "code.bisect.code",
        "documentation": {}
    },
    {
        "label": "grade_map",
        "kind": 5,
        "importPath": "code.bisect.code",
        "description": "code.bisect.code",
        "peekOfCode": "grade_map = {\n    'F9': 0,\n    'E8': 40,\n    'C4': 60,\n    'C6': 50,\n    'C5': 55,\n    'A1': 75,\n    'B3': 65,\n    'D7': 45,\n    'B2': 70,",
        "detail": "code.bisect.code",
        "documentation": {}
    },
    {
        "label": "grade_map",
        "kind": 5,
        "importPath": "code.bisect.test",
        "description": "code.bisect.test",
        "peekOfCode": "grade_map = {\n    'F9': 0,\n    'E8': 40,\n    'C4': 60,\n    'C6': 50,\n    'C5': 55,\n    'A1': 75,\n    'B3': 65,\n    'D7': 45,\n    'B2': 70,",
        "detail": "code.bisect.test",
        "documentation": {}
    },
    {
        "label": "is_a_palindrome",
        "kind": 2,
        "importPath": "code.palindrome.palindrome",
        "description": "code.palindrome.palindrome",
        "peekOfCode": "def is_a_palindrome(value: str) -> bool:\n    \"\"\" Checks if a given value is a `palindrome` \"\"\"\n    return value == value[::-1]\ndef main() -> None:\n    value_to_check = input('Enter value to know if it is a palindrome: ')\n    if is_a_palindrome(value_to_check):\n        print(F'{ value_to_check } is a palindrome')\n    else:\n        print(F'{ value_to_check } is not a palindrome')\nif __name__ == '__main__':",
        "detail": "code.palindrome.palindrome",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.palindrome.palindrome",
        "description": "code.palindrome.palindrome",
        "peekOfCode": "def main() -> None:\n    value_to_check = input('Enter value to know if it is a palindrome: ')\n    if is_a_palindrome(value_to_check):\n        print(F'{ value_to_check } is a palindrome')\n    else:\n        print(F'{ value_to_check } is not a palindrome')\nif __name__ == '__main__':\n    main()",
        "detail": "code.palindrome.palindrome",
        "documentation": {}
    },
    {
        "label": "string_reversal_method_1",
        "kind": 2,
        "importPath": "code.string_reversal.string_reversal",
        "description": "code.string_reversal.string_reversal",
        "peekOfCode": "def string_reversal_method_1(value: str) -> str:\n    reverse = []\n    for val in value:\n        reverse.insert(0, val)\n    return ''.join(reverse)\ndef string_reversal_method_2(value: str) -> str:\n    return reduce(lambda a, b: ''.join([b, a]), value)\ndef string_reversal_method_3(value: str) -> str:\n    value_as_list = [val for val in value]\n    value_as_list.reverse()",
        "detail": "code.string_reversal.string_reversal",
        "documentation": {}
    },
    {
        "label": "string_reversal_method_2",
        "kind": 2,
        "importPath": "code.string_reversal.string_reversal",
        "description": "code.string_reversal.string_reversal",
        "peekOfCode": "def string_reversal_method_2(value: str) -> str:\n    return reduce(lambda a, b: ''.join([b, a]), value)\ndef string_reversal_method_3(value: str) -> str:\n    value_as_list = [val for val in value]\n    value_as_list.reverse()\n    return ''.join(value_as_list)\ndef string_reversal_method_4(value: str) -> str:\n    return value[::-1]",
        "detail": "code.string_reversal.string_reversal",
        "documentation": {}
    },
    {
        "label": "string_reversal_method_3",
        "kind": 2,
        "importPath": "code.string_reversal.string_reversal",
        "description": "code.string_reversal.string_reversal",
        "peekOfCode": "def string_reversal_method_3(value: str) -> str:\n    value_as_list = [val for val in value]\n    value_as_list.reverse()\n    return ''.join(value_as_list)\ndef string_reversal_method_4(value: str) -> str:\n    return value[::-1]",
        "detail": "code.string_reversal.string_reversal",
        "documentation": {}
    },
    {
        "label": "string_reversal_method_4",
        "kind": 2,
        "importPath": "code.string_reversal.string_reversal",
        "description": "code.string_reversal.string_reversal",
        "peekOfCode": "def string_reversal_method_4(value: str) -> str:\n    return value[::-1]",
        "detail": "code.string_reversal.string_reversal",
        "documentation": {}
    }
]